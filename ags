#!/bin/bash

CONFIG="$HOME/.config/ags/scanlist"


function help_text() {
cat <<EOF  

all-git-status (ags) scans the list of paths provided in
\$HOME/.config/ags/scanlist for git statuses and unpushed commits to
the remote branch that's currently tracked.

USAGE:
    ags [OPTIONS]

OPTIONS:
    -h, --help          Prints help information.
                        Use --help for more details.
    -e, --edit          Open repository scanlist with \$EDITOR.
    -v, --verbose       Prints more details about each repository.

EOF
}

# colors
_N='\033[0m'
_R='\033[0;31m'
_G='\033[0;32m'
_Y='\033[0;33m'
_B='\033[0;34m'
_P='\033[0;35m'
_C='\033[0;36m'
_S='\033[0;37m' # Gray (Soft)

# all git-status
max_len=24
ok="[ok]"
color=true
all_clean=true

REPOS=$HOME/repos


# create scan list
# TODO: create a system-wide repo scanner
function main() {
scanlist=()
while IFS= read -r line; do scanlist+=($line); done < "$CONFIG"

# filter through scanlist to check if paths are valid git repositories
# only accept directories which:
#   1. exists
#   2. are at the root of the git repository they are in
filterlist=()
status_only=()
for i in ${scanlist[@]}; do
  full=${i/\~/$HOME}
  if [[ -d $full ]]; then
    if [[ -e $full/.git ]]; then
      if [[ $(git -C $full rev-parse --show-toplevel 2>/dev/null) = "$full" ]]; then
        filterlist+=($full)
        tracking=$(git -C $full status -sb)
        if [[ $tracking != *"..."* ]]; then
          # printf "${_Y}has no tracking branch:${_N} $i\n"
          status_only+=($full)
        fi
      else
        printf "${_Y}not at git root:${_N} $i\n"
      fi
    else
      printf "${_Y}not a git repo:${_N} $i\n"
    fi
  else
    printf "${_Y}invalid directory:${_N} $i\n"
  fi
done

printf "\n"

for dir in ${filterlist[@]}; do
  short="${dir/$HOME/~}"
  printf "${_S}${short}${_N}\n"

  # git status
  IFS=$'\n' read -r -d '' -a stats < <(git -C $dir status -s)

  # print git status
  for i in "${stats[@]}"; do
    unstaged=${i:1:1}
    if [[ $unstaged == " " ]]; then
      printf "${_G}$i${_N}\n"
    else
      printf "${_R}$i${_N}\n"
    fi
  done

  # if branch has been previously identified to have
  # no tracked remote branch, then skip the next step
  [[ " ${status_only[*]} " =~ " ${dir} " ]] && continue

  # git unpushed commits (requires a remote tracking branch)
  IFS=$'\n' read -r -d '' -a commits < <(git -C $dir cherry -v --abbrev)

  # print unpushed commits
  for i in "${commits[@]}"; do
    tag=${i%% *}
    aftertag=${i#* }
    commit=${aftertag%% *}
    color_commit=${_Y}${commit}${_N}
    aftercommit=${i#* }
    post=${aftercommit#* }
    printf " $tag $color_commit $post\n"
  done

done
}

# handle arguments
POSITIONAL_ARGS=()
EXECUTE_MAIN=true
while [[ $# -gt 0 ]]; do
  case $1 in
    -e|--edit)
      EDIT=true
      shift
      echo "open the config file with editor"
      $EDITOR $CONFIG
      exit 0
      ;;
    -h|--help)
      HELP=true
      shift # past argument
      help_text
      exit 0
      ;;
    -*|--*)
      echo "Unknown option $1"
      exit 1
      ;;
    *)
      POSITIONAL_ARGS+=("$1") # save positional arg
      shift # past argument
      ;;
  esac
done

# execute if no arguments are passed.
[ -z $POSITIONAL_ARGS ] && main
