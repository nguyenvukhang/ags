#!/bin/bash

CONFIG="$HOME/.config/ags/scanlist"


function help_text() {
cat <<EOF  

all-git-status (ags) scans the list of paths provided in
\$HOME/.config/ags/scanlist for git statuses and unpushed commits to
the remote branch that's currently tracked.

USAGE:
    ags [OPTIONS]

OPTIONS:
    -h, --help          Prints help information.
                        Use --help for more details.
    -e, --edit          Open repository scanlist with \$EDITOR.
    -v, --verbose       Prints more details about each repository.

EOF
}

# colors
_N='\033[0m'
_R='\033[0;31m'
_G='\033[0;32m'
_Y='\033[0;33m'
_B='\033[0;34m'
_P='\033[0;35m'
_C='\033[0;36m'
_S='\033[0;37m' # Gray (Soft)

# all git-status
max_len=24
ok="[ok]"
color=true
all_clean=true

REPOS=$HOME/repos


# create scan list
# TODO: create a system-wide repo scanner
function main() {
scanlist=()
while IFS= read -r line; do scanlist+=($line); done < "$CONFIG"

# filter through scanlist to check if paths are valid git repositories
# only accept directories which:
#   1. exists
#   2. are at the root of the git repository they are in
filterlist=()
status_only=()
for i in ${scanlist[@]}; do
  full=${i/\~/$HOME}
  if [[ -d $full ]]; then
    if [[ -e $full/.git ]]; then
      if [[ $(git -C $full rev-parse --show-toplevel 2>/dev/null) = "$full" ]]; then
        filterlist+=($full)
        tracking=$(git -C $full status -sb)
        if [[ $tracking != *"..."* ]]; then
          # printf "${_Y}has no tracking branch:${_N} $i\n"
          status_only+=($full)
        fi
      else
        printf "${_Y}not at git root:${_N} $i\n"
      fi
    else
      printf "${_Y}not a git repo:${_N} $i\n"
    fi
  else
    printf "${_Y}invalid directory:${_N} $i\n"
  fi
done

printf "\n"

# operate on the filtered list
# for each repository, check for:
#   1. git status
#   2. commits yet to be pushed to currently tracked branch

# to be ran just before continuing to the next iteration.
function check_clean() {
  [[ $repo_clean == true ]] \
    && printf "${_G} [ok]${_N}\n" \
    || all_repos_clean=false
}
all_repos_clean=true

for dir in ${filterlist[@]}; do
  repo_clean=true
  short="${dir/$HOME/~}"
  colored_short="${_N}$short${_N}"
  printf "${_S}[${_N}${colored_short}${_S}]${_N}"

  # git status
  IFS=$'\n' read -r -d '' -a stats < <(git -C $dir status -s)

  if [[ $stats ]]; then
    printf "\n"
    repo_clean=false
    # print git status
    for i in "${stats[@]}"; do
      unstaged=${i:1:1}
      if [[ $unstaged == " " ]]; then
        printf "${_G}$i${_N}\n"
      else
        printf "${_R}$i${_N}\n"
      fi
    done
  fi

  # if branch has been previously identified to have
  # no tracked remote branch, then skip the next step
  if [[ " ${status_only[*]} " =~ " ${dir} " ]]; then
    check_clean
    continue
  fi


  # git unpushed commits (requires a remote tracking branch)
  IFS=$'\n' read -r -d '' -a commits < <(git -C $dir cherry -v --abbrev)

  if [[ $commits ]]; then
    printf "\n"
    repo_clean=false
    # print unpushed commits
    for i in "${commits[@]}"; do
      tag=${i%% *}
      aftertag=${i#* }
      commit=${aftertag%% *}
      color_commit=${_Y}${commit}${_N}
      aftercommit=${i#* }
      post=${aftercommit#* }
      printf " $tag $color_commit $post\n"
    done
  fi

  check_clean

done

if [[ $all_repos_clean == true ]]; then
  printf "\n${_G}all repos clean!${_N}\n"
fi
}

# handle arguments
POSITIONAL_ARGS=()
EXECUTE_MAIN=true
while [[ $# -gt 0 ]]; do
  case $1 in
    -e|--edit)
      EDIT=true
      shift
      echo "open the config file with editor"
      $EDITOR $CONFIG
      exit 0
      ;;
    -h|--help)
      HELP=true
      shift # past argument
      help_text
      exit 0
      ;;
    -v|--verbose)
      VERBOSE=true
      shift # past argument
      exit 0
      ;;
    -*|--*)
      echo "Unknown option $1"
      exit 1
      ;;
    *)
      POSITIONAL_ARGS+=("$1") # save positional arg
      shift # past argument
      ;;
  esac
done

# execute if no arguments are passed.
[ -z $POSITIONAL_ARGS ] && main
