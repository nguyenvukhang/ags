#!/bin/bash

# colors
_N='\033[0m'
_R='\033[0;31m'
_G='\033[0;32m'
_Y='\033[0;33m'
_B='\033[0;34m'
_P='\033[0;35m'
_C='\033[0;36m'
_S='\033[0;37m' # Gray (Soft)

# all git-status
max_len=24
ok="[ok]"
color=true
all_clean=true


function color_up() {
  local tag=$1
  local map=(
    "A,${_G}"
    "D,${_R}"
    # "+,${_N}"
    # "M,${_N}"
    # "??,${_N}"
  )
  for symbol_color in ${map[@]}; do
    symbol=${symbol_color%%,*}
    color=${symbol_color#*,}
    tag=${tag/$symbol/${color}${symbol}${_N}}
  done
  echo "got here"
  printf "$tag"
}


REPOS=$HOME/repos

CONFIG="$HOME/.config/ags/scanlist"

# create scan list
# TODO: create a system-wide repo scanner
scanlist=()
while IFS= read -r line; do scanlist+=($line); done < "$CONFIG"

# filter through scanlist to check if paths are valid git repositories
# only accept directories which:
#   1. exists
#   2. are at the root of the git repository they are in
filterlist=()
status_only=()
for i in ${scanlist[@]}; do
  full=${i/\~/$HOME}
  if [[ -d $full ]]; then
    if [[ -e $full/.git ]]; then
      if [[ $(git -C $full rev-parse --show-toplevel 2>/dev/null) = "$full" ]]; then
        filterlist+=($full)
        tracking=$(git -C $full status -sb)
        if [[ $tracking != *"..."* ]]; then
          printf "${_Y}has no tracking branch:${_N} $i\n"
          status_only+=($full)
        fi
      else
        printf "${_Y}not at git root:${_N} $i\n"
      fi
    else
      printf "${_Y}not a git repo:${_N} $i\n"
    fi
  else
    printf "${_R}invalid directory:${_N} $i\n"
  fi
done

printf "\n"

for dir in ${filterlist[@]}; do
  short="${dir/$HOME/~}"
  printf "${_S}${short}${_N}\n"

  # git status
  IFS=$'\n' read -r -d '' -a stats < <(git -C $dir status -s)

  # print git status
  for i in "${stats[@]}"; do
    unstaged=${i:1:1}
    if [[ $unstaged == " " ]]; then
      printf "${_G}$i${_N}\n"
    else
      printf "${_R}$i${_N}\n"
    fi
  done

  [[ " ${status_only[*]} " =~ " ${dir} " ]] && continue

  # git unpushed commits
  IFS=$'\n' read -r -d '' -a commits < <(git -C $dir cherry -v --abbrev)

  # list unpushed commits
  for i in "${commits[@]}"; do
    tag=${i%% *}
    aftertag=${i#* }
    commit=${aftertag%% *}
    color_commit=${_Y}${commit}${_N}
    aftercommit=${i#* }
    post=${aftercommit#* }
    printf " $tag $color_commit $post\n"
  done

done

# for dir_repo in $scanlist; do
#   local dir=${dir_repo%%,*}
#   local repo=${dir_repo#*,}
#   [[ ${blacklist[(r)$repo]} == $repo ]] && continue # if in BLACKLIST, continue
#   local len=${#repo}
# 
#   local stats=()
#   while IFS= read -r line; do
#     stats+=( "$line" )
#   done < <( git -C $dir status -s )
# 
#   local commits=()
#   while IFS= read -r line; do
#     commits+=( "$line" )
#   done < <( git -C $dir cherry -v --abbrev 2> /dev/null )
# 
#   local clean=true
# 
#   # uncommited changes
#   [ "$stats" ] && clean=false
# 
#   # unpushed commits
#   [ "$commits" ] && clean=false
# 
#   if [ "$clean" = false ]; then
#     all_clean=false
#     echo "\n${GRAY}[${CYAN}${repo}${GRAY}]${NORMAL}"
# 
#     # print git status
#     for i in $stats; do
#       local tag=${i[0,2]}
#       [ "$color" = true ] && tag=$(color_up $tag)
#       local file=${i[4,-1]}
#       echo "$tag $file"
#     done
#   fi
# done
# 
# 
# if [ "$all_clean" = true ]; then
#   echo "\nscanned:"
#   for dir_repo in $scanlist; do
#     local repo=${dir_repo#*,}
#     [[ ${blacklist[(r)$repo]} == $repo ]] && continue # if in BLACKLIST, continue
#     echo "- $repo"
#   done
#   echo "\n${GREEN}all clean!${NORMAL}"
# fi
