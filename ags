#!/bin/bash

SCANLIST="$HOME/.config/ags/scanlist"


function send_help_text() {
cat <<EOF  
ags scans the list of paths provided in ~/.config/ags/scanlist
for git statuses and unpushed commits to the remote branch that's
currently tracked.

USAGE:
    ags [OPTIONS]

OPTIONS
    -h, --help
          Prints help information. Use --help for more details.
          For more information, run \`man ags\`.

    -l    Prints more details about each repository.

    -e, --edit
          Opens default scanlist with $EDITOR.
EOF
}

# colors and aesthetics
_N='\033[0m'    # Normal
_R='\033[0;31m' # Red
_G='\033[0;32m' # Green
_Y='\033[0;33m' # Yellow
_B='\033[0;34m' # Blue
_P='\033[0;35m' # Purple
_C='\033[0;36m' # Cyan
_S='\033[1;37m' # Gray (Soft)
indent=2
spaces=$(printf "%-${indent}s")

function filter_scanlist() {
  # filter through scanlist to check if paths are valid git repositories
  # only accept directories which:
  #   1. exists
  #   2. are at the root of the git repository they are in

  # read the full scanlist from config file
  scanlist=()
  while IFS= read -r line; do scanlist+=($line); done < "$SCANLIST"

  filterlist=()
  status_only=()
  for i in ${scanlist[@]}; do
    full=${i/\~/$HOME}
    if [[ -d $full ]]; then
      if [[ -e $full/.git ]]; then
        if [[ $(git -C $full rev-parse --show-toplevel 2>/dev/null) = "$full" ]]; then
          filterlist+=($full)
          tracking=$(git -C $full status -sb)
          if [[ $tracking != *"..."* || $tracking == *"[gone]"* ]]; then
            status_only+=($full)
          fi
        else
          printf "${_Y}not at git root:${_N} $i\n"
        fi
      else
        printf "${_Y}not a git repo:${_N} $i\n"
      fi
    else
      printf "${_Y}invalid directory:${_N} $i\n"
    fi
  done
}

# title meant for use in LONG_FORMAT.
# prints before git status and git cherry
function long_title() {
  if [[ $repo_clean == true ]]; then
    printf "${_G}ok${_S} $short${_N}\n"
  else
    printf "${_S}$short${_N}\n"
    all_repos_clean=false
  fi
}

# one-liner summary of git repository
# S: denotes unstaged files
# C: denotes unpushed commits
# ok: repo is clean
function short_summary() {
  msg=""
  if [[ $repo_clean == false ]]; then
    all_repos_clean=false
    [[ $has_stats == true ]] \
      && msg+="S" \
      || msg+=" "
    [[ $has_commits == true ]] \
      && msg+="C" \
      || msg+=" "
    printf "${_Y}$msg${_N} $short\n"
  else
    printf "${_G}ok${_N} $short\n"
  fi
}

# if there are unpushed commits, then print those
# and declare that the current repo is not clean
function handle_commits() {
  # cancel if there are no unpushed commits
  [[ -z $commits ]] && return
  # print unpushed commits
  for i in "${commits[@]}"; do
    tag=${i%% *}
    aftertag=${i#* }
    commit=${aftertag%% *}
    color_commit=${_Y}${commit}${_N}
    aftercommit=${i#* }
    post=${aftercommit#* }
    printf " $tag $color_commit $post\n"
  done
}

# operate on the filtered list
# for each repository, check for:
#   1. git status
#   2. commits yet to be pushed to currently tracked branch
function iterate_filtered() {
  all_repos_clean=true
  for dir in ${filterlist[@]}; do
    repo_clean=true
    has_stats=false
    has_commits=false
    short="${dir/$HOME/~}"

    # git status
    # IFS=$'\n' read -r -d '' -a stats < <(git -C $dir status -s)
    stats=$(git -C $dir status -s)
    [[ $stats ]] && repo_clean=false && has_stats=true

    # if branch has been previously identified to have
    # no tracked remote branch, then skip the next step
    if [[ " ${status_only[*]} " =~ " ${dir} " ]]; then
      # handle output (status only)
      if [[ $LONG_FORMAT == true ]]; then
        long_title
        [[ $stats ]] && git -C $dir status -s
      else
        short_summary
      fi
      continue
    fi

    # git unpushed commits (requires a remote tracking branch)
    IFS=$'\n' read -r -d '' -a commits < <(git -C $dir cherry -v --abbrev)
    [[ $commits ]] && repo_clean=false && has_commits=true

    # handle output (status and commits)
    if [[ $LONG_FORMAT == true ]]; then
      long_title
      [[ $stats ]] && git -C $dir status -s
      handle_commits
    else
      short_summary
    fi
  done

  # if all repos are clean, then print an affirmative message
  if [[ $all_repos_clean == true ]]; then
    printf "\n${_G}all repos clean!${_N}\n"
  fi
}

function run_edit() {
  if [ ! -z "$EDITOR" ]; then
    $EDITOR $SCANLIST
  elif command -v nvim &> /dev/null; then
    nvim $SCANLIST
  elif command -v vim &> /dev/null; then
    vim $SCANLIST
  elif command -v nano &> /dev/null; then
    nano $SCANLIST
  fi
}

function handle_arguments() {
  POSITIONAL_ARGS=()
  while [[ $# -gt 0 ]]; do
    case $1 in
      -e|--edit)
        shift; run_edit; exit 0;;
      -h|--help)
        shift; send_help_text; exit 0;;
      -l)
        LONG_FORMAT=true; shift;;
      -*|--*)
        echo "Unknown option $1"; exit 1;;
      *)
        POSITIONAL_ARGS+=("$1"); shift;;
    esac
  done

  if [[ ${#POSITIONAL_ARGS[@]} -ne 0 ]]; then
    # if more than one positional argument is supplied,
    # cancel execution and send help text
    if [[ ${#POSITIONAL_ARGS[@]} -gt 1 ]]; then
      printf "Multiple positional arguments are currently unsupported.\n"
      send_help_text
      exit 0
    fi
    # if a valid file is supplied as the first positional argument,
    # then use it instead of the default ~/.config/ags/scanlist
    SCAN_THIS="${POSITIONAL_ARGS[0]}"
    if [ -f $SCAN_THIS ]; then
      SCANLIST=$SCAN_THIS
    else
      printf "scanlist \"${SCAN_THIS}\" not found\n"
      exit 1
    fi
  fi
}

# main flow
handle_arguments "$@"
filter_scanlist
iterate_filtered
